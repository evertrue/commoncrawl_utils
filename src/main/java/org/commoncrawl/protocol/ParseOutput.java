// File generated by rpc compiler. Do not edit.

package org.commoncrawl.protocol;

import java.io.DataInput;
import java.io.DataOutput;
import java.util.BitSet;
import java.io.IOException;
import org.apache.hadoop.io.Writable;
import org.apache.hadoop.io.WritableComparable;
import org.apache.hadoop.record.Buffer;
import org.commoncrawl.util.shared.FlexBuffer;
import org.commoncrawl.util.shared.TextBytes;
import org.commoncrawl.util.shared.MurmurHash;
import org.commoncrawl.util.shared.ImmutableBuffer;
import org.commoncrawl.rpc.BinaryProtocol;
import org.apache.hadoop.util.ReflectionUtils;
import org.apache.hadoop.conf.Configuration;

// Generated File: ParseOutput
public class ParseOutput extends org.commoncrawl.rpc.RPCStruct<ParseOutput> implements Writable {

	// optimized constructor helper 
	public static ParseOutput newInstance(Configuration conf) {
		return ReflectionUtils.newInstance(ParseOutput.class, conf);
	}

	// Writable Implementation
	public void write(DataOutput out) throws IOException {
		this.serialize(out, new BinaryProtocol());
	}

	public void readFields(DataInput in) throws IOException {
		this.deserialize(in, new BinaryProtocol());
	}

	// Field Constants
	public static final int Field_NORMALIZEDMIMETYPE = 3;
	public static final int Field_HOSTIPADDRESS = 4;
	public static final int Field_FETCHTIME = 5;
	public static final int Field_HEADERS = 8;
	public static final int Field_RAWCONTENT = 9;
	static final int FieldID_MAX = Field_RAWCONTENT;

	// Field Declarations
	private BitSet __validFields = new BitSet(FieldID_MAX + 1);

	private TextBytes normalizedMimeType = new TextBytes();
	private TextBytes hostIPAddress = new TextBytes();
	private long fetchTime;
	private TextBytes headers = new TextBytes();
	private FlexBuffer rawContent = new FlexBuffer();

	// Default Constructor
	public ParseOutput() {
	}

	// Accessors

	public final boolean isFieldDirty(int fieldId) {
		return __validFields.get(fieldId);
	}

	public final ParseOutput setFieldDirty(int fieldId) {
		__validFields.set(fieldId);
		return this;
	}

	public final ParseOutput setFieldClean(int fieldId) {
		__validFields.clear(fieldId);
		return this;
	}

	public TextBytes getNormalizedMimeTypeAsTextBytes() {
		return normalizedMimeType;
	}

	public String getNormalizedMimeType() {
		return normalizedMimeType.toString();
	}

	public ParseOutput setNormalizedMimeType(String normalizedMimeType) {
		__validFields.set(Field_NORMALIZEDMIMETYPE);
		this.normalizedMimeType.set(normalizedMimeType);
		return this;
	}

	public TextBytes getHostIPAddressAsTextBytes() {
		return hostIPAddress;
	}

	public String getHostIPAddress() {
		return hostIPAddress.toString();
	}

	public ParseOutput setHostIPAddress(String hostIPAddress) {
		__validFields.set(Field_HOSTIPADDRESS);
		this.hostIPAddress.set(hostIPAddress);
		return this;
	}

	public long getFetchTime() {
		return fetchTime;
	}

	public ParseOutput setFetchTime(long fetchTime) {
		__validFields.set(Field_FETCHTIME);
		this.fetchTime = fetchTime;
		return this;
	}

	public TextBytes getHeadersAsTextBytes() {
		return headers;
	}

	public String getHeaders() {
		return headers.toString();
	}

	public ParseOutput setHeaders(String headers) {
		__validFields.set(Field_HEADERS);
		this.headers.set(headers);
		return this;
	}

	public ImmutableBuffer getRawContent() {
		return new ImmutableBuffer(rawContent);
	}

	public ParseOutput setRawContent(FlexBuffer rawContent) {
		__validFields.set(Field_RAWCONTENT);
		this.rawContent = rawContent;
		return this;
	}

	public ParseOutput setRawContent(Buffer rawContent, boolean shared) {
		__validFields.set(Field_RAWCONTENT);
		this.rawContent = new FlexBuffer(rawContent.get(), 0, rawContent.getCount(), shared);
		return this;
	}

	// Object Dirty support 

	public final boolean isObjectDirty() {
		boolean isDirty = !__validFields.isEmpty();
		return isDirty;
	}

	// serialize implementation 
	public final void serialize(DataOutput output, BinaryProtocol encoder) throws java.io.IOException {
		encoder.beginFields(output);
		// serialize field:normalizedMimeType
		if (__validFields.get(Field_NORMALIZEDMIMETYPE)) {
			encoder.beginField(output, "normalizedMimeType", Field_NORMALIZEDMIMETYPE);
			encoder.writeTextBytes(output, normalizedMimeType);
		}
		// serialize field:hostIPAddress
		if (__validFields.get(Field_HOSTIPADDRESS)) {
			encoder.beginField(output, "hostIPAddress", Field_HOSTIPADDRESS);
			encoder.writeTextBytes(output, hostIPAddress);
		}
		// serialize field:fetchTime
		if (__validFields.get(Field_FETCHTIME)) {
			encoder.beginField(output, "fetchTime", Field_FETCHTIME);
			encoder.writeLong(output, fetchTime);
		}
		// serialize field:headers
		if (__validFields.get(Field_HEADERS)) {
			encoder.beginField(output, "headers", Field_HEADERS);
			encoder.writeTextBytes(output, headers);
		}
		// serialize field:rawContent
		if (__validFields.get(Field_RAWCONTENT)) {
			encoder.beginField(output, "rawContent", Field_RAWCONTENT);
			encoder.writeFlexBuffer(output, rawContent);
		}
		encoder.endFields(output);
	}

	// deserialize implementation 
	public final void deserialize(DataInput input, BinaryProtocol decoder) throws java.io.IOException {
		// clear existing data first  
		clear();

		// reset protocol object to unknown field id enconding mode (for compatibility)
		decoder.pushFieldIdEncodingMode(BinaryProtocol.FIELD_ID_ENCODING_MODE_UNKNOWN);
		// keep reading fields until terminator (-1) is located 
		int fieldId;
		while ((fieldId = decoder.readFieldId(input)) != -1) {
			switch (fieldId) {
			case Field_NORMALIZEDMIMETYPE: {
				__validFields.set(Field_NORMALIZEDMIMETYPE);
				decoder.readTextBytes(input, normalizedMimeType);
			}
				break;
			case Field_HOSTIPADDRESS: {
				__validFields.set(Field_HOSTIPADDRESS);
				decoder.readTextBytes(input, hostIPAddress);
			}
				break;
			case Field_FETCHTIME: {
				__validFields.set(Field_FETCHTIME);
				fetchTime = decoder.readLong(input);
			}
				break;
			case Field_HEADERS: {
				__validFields.set(Field_HEADERS);
				decoder.readTextBytes(input, headers);
			}
				break;
			case Field_RAWCONTENT: {
				__validFields.set(Field_RAWCONTENT);
				decoder.readFlexBuffer(input, rawContent);
			}
				break;
			}
		}
		// pop extra encoding mode off of stack 
		decoder.popFieldIdEncodingMode();
	}

	// clear implementation 
	public final void clear() {
		__validFields.clear();
		normalizedMimeType.clear();
		hostIPAddress.clear();
		fetchTime = 0;
		headers.clear();
		rawContent.reset();
	}

	// equals implementation 
	public final boolean equals(final Object peer_) {
		if (!(peer_ instanceof ParseOutput)) {
			return false;
		}
		if (peer_ == this) {
			return true;
		}
		ParseOutput peer = (ParseOutput) peer_;
		boolean ret = __validFields.equals(peer.__validFields);
		if (!ret)
			return ret;
		if (__validFields.get(Field_NORMALIZEDMIMETYPE)) {
			ret = normalizedMimeType.equals(peer.normalizedMimeType);
			if (!ret)
				return ret;
		}
		if (__validFields.get(Field_HOSTIPADDRESS)) {
			ret = hostIPAddress.equals(peer.hostIPAddress);
			if (!ret)
				return ret;
		}
		if (__validFields.get(Field_FETCHTIME)) {
			ret = (fetchTime == peer.fetchTime);
			if (!ret)
				return ret;
		}
		if (__validFields.get(Field_HEADERS)) {
			ret = headers.equals(peer.headers);
			if (!ret)
				return ret;
		}
		if (__validFields.get(Field_RAWCONTENT)) {
			ret = rawContent.equals(peer.rawContent);
			if (!ret)
				return ret;
		}
		return ret;
	}

	// clone implementation 
	@SuppressWarnings("unchecked")
	public final Object clone() throws CloneNotSupportedException {
		ParseOutput other = new ParseOutput();
		other.__validFields.or(this.__validFields);
		if (__validFields.get(Field_NORMALIZEDMIMETYPE)) {
			other.normalizedMimeType = (TextBytes) this.normalizedMimeType.clone();
		}
		if (__validFields.get(Field_HOSTIPADDRESS)) {
			other.hostIPAddress = (TextBytes) this.hostIPAddress.clone();
		}
		if (__validFields.get(Field_FETCHTIME)) {
			other.fetchTime = this.fetchTime;
		}
		if (__validFields.get(Field_HEADERS)) {
			other.headers = (TextBytes) this.headers.clone();
		}
		if (__validFields.get(Field_RAWCONTENT)) {
			other.rawContent = (FlexBuffer) this.rawContent.clone();
		}
		return other;
	}

	// merge implementation 
	@SuppressWarnings("unchecked")
	public final void merge(ParseOutput peer) throws CloneNotSupportedException {
		__validFields.or(peer.__validFields);
		if (peer.__validFields.get(Field_NORMALIZEDMIMETYPE)) {
			this.normalizedMimeType = (TextBytes) peer.normalizedMimeType.clone();
		}
		if (peer.__validFields.get(Field_HOSTIPADDRESS)) {
			this.hostIPAddress = (TextBytes) peer.hostIPAddress.clone();
		}
		if (peer.__validFields.get(Field_FETCHTIME)) {
			this.fetchTime = peer.fetchTime;
		}
		if (peer.__validFields.get(Field_HEADERS)) {
			this.headers = (TextBytes) peer.headers.clone();
		}
		if (peer.__validFields.get(Field_RAWCONTENT)) {
			this.rawContent = (FlexBuffer) peer.rawContent.clone();
		}
	}

	// hashCode implementation 
	public final int hashCode() {
		int result = 1;
		result = MurmurHash.hash(normalizedMimeType.getBytes(), normalizedMimeType.getOffset(),
				normalizedMimeType.getLength(), result);
		result = MurmurHash
				.hash(hostIPAddress.getBytes(), hostIPAddress.getOffset(), hostIPAddress.getLength(), result);
		result = MurmurHash.hashLong(fetchTime, result);
		result = MurmurHash.hash(headers.getBytes(), headers.getOffset(), headers.getLength(), result);
		result = MurmurHash.hash(rawContent.get(), rawContent.getOffset(), rawContent.getCount(), result);
		return result;
	}
}
