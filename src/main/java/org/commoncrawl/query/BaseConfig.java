// File generated by rpc compiler. Do not edit.

package org.commoncrawl.query;

import java.io.DataInput;
import java.io.DataOutput;
import java.util.BitSet;
import java.io.IOException;
import org.apache.hadoop.io.Writable;
import org.apache.hadoop.io.WritableComparable;
import org.apache.hadoop.record.Buffer;
import org.commoncrawl.util.shared.FlexBuffer;
import org.commoncrawl.util.shared.TextBytes;
import org.commoncrawl.util.shared.MurmurHash;
import org.commoncrawl.util.shared.ImmutableBuffer;
import org.commoncrawl.rpc.BinaryProtocol;
import org.apache.hadoop.util.ReflectionUtils;
import org.apache.hadoop.conf.Configuration;

// Generated File: BaseConfig
public class BaseConfig extends org.commoncrawl.rpc.RPCStruct<BaseConfig> implements Writable {

	// optimized constructor helper 
	public static BaseConfig newInstance(Configuration conf) {
		return ReflectionUtils.newInstance(BaseConfig.class, conf);
	}

	// Writable Implementation
	public void write(DataOutput out) throws IOException {
		this.serialize(out, new BinaryProtocol());
	}

	public void readFields(DataInput in) throws IOException {
		this.deserialize(in, new BinaryProtocol());
	}

	// Field Constants
	public static final int Field_FILESYSTEM = 1;
	public static final int Field_QUERYRESULTSDIR = 3;
	public static final int Field_SLAVENAME = 6;
	static final int FieldID_MAX = Field_SLAVENAME;

	// Field Declarations
	private BitSet __validFields = new BitSet(FieldID_MAX + 1);

	private TextBytes fileSystem = new TextBytes();
	private TextBytes queryResultsDir = new TextBytes();
	private TextBytes slaveName = new TextBytes();

	// Default Constructor
	public BaseConfig() {
	}

	// Accessors

	public final boolean isFieldDirty(int fieldId) {
		return __validFields.get(fieldId);
	}

	public final BaseConfig setFieldDirty(int fieldId) {
		__validFields.set(fieldId);
		return this;
	}

	public final BaseConfig setFieldClean(int fieldId) {
		__validFields.clear(fieldId);
		return this;
	}

	public TextBytes getFileSystemAsTextBytes() {
		return fileSystem;
	}

	public String getFileSystem() {
		return fileSystem.toString();
	}

	public BaseConfig setFileSystem(String fileSystem) {
		__validFields.set(Field_FILESYSTEM);
		this.fileSystem.set(fileSystem);
		return this;
	}

	public TextBytes getQueryResultsDirAsTextBytes() {
		return queryResultsDir;
	}

	public String getQueryResultsDir() {
		return queryResultsDir.toString();
	}

	public BaseConfig setQueryResultsDir(String queryResultsDir) {
		__validFields.set(Field_QUERYRESULTSDIR);
		this.queryResultsDir.set(queryResultsDir);
		return this;
	}

	public TextBytes getSlaveNameAsTextBytes() {
		return slaveName;
	}

	public String getSlaveName() {
		return slaveName.toString();
	}

	public BaseConfig setSlaveName(String slaveName) {
		__validFields.set(Field_SLAVENAME);
		this.slaveName.set(slaveName);
		return this;
	}

	// Object Dirty support 

	public final boolean isObjectDirty() {
		boolean isDirty = !__validFields.isEmpty();
		return isDirty;
	}

	// serialize implementation 
	public final void serialize(DataOutput output, BinaryProtocol encoder) throws java.io.IOException {
		encoder.beginFields(output);
		// serialize field:fileSystem
		if (__validFields.get(Field_FILESYSTEM)) {
			encoder.beginField(output, "fileSystem", Field_FILESYSTEM);
			encoder.writeTextBytes(output, fileSystem);
		}
		// serialize field:queryResultsDir
		if (__validFields.get(Field_QUERYRESULTSDIR)) {
			encoder.beginField(output, "queryResultsDir", Field_QUERYRESULTSDIR);
			encoder.writeTextBytes(output, queryResultsDir);
		}
		// serialize field:slaveName
		if (__validFields.get(Field_SLAVENAME)) {
			encoder.beginField(output, "slaveName", Field_SLAVENAME);
			encoder.writeTextBytes(output, slaveName);
		}
		encoder.endFields(output);
	}

	// deserialize implementation 
	public final void deserialize(DataInput input, BinaryProtocol decoder) throws java.io.IOException {
		// clear existing data first  
		clear();

		// reset protocol object to unknown field id enconding mode (for compatibility)
		decoder.pushFieldIdEncodingMode(BinaryProtocol.FIELD_ID_ENCODING_MODE_UNKNOWN);
		// keep reading fields until terminator (-1) is located 
		int fieldId;
		while ((fieldId = decoder.readFieldId(input)) != -1) {
			switch (fieldId) {
			case Field_FILESYSTEM: {
				__validFields.set(Field_FILESYSTEM);
				decoder.readTextBytes(input, fileSystem);
			}
				break;
			case Field_QUERYRESULTSDIR: {
				__validFields.set(Field_QUERYRESULTSDIR);
				decoder.readTextBytes(input, queryResultsDir);
			}
				break;
			case Field_SLAVENAME: {
				__validFields.set(Field_SLAVENAME);
				decoder.readTextBytes(input, slaveName);
			}
				break;
			}
		}
		// pop extra encoding mode off of stack 
		decoder.popFieldIdEncodingMode();
	}

	// clear implementation 
	public final void clear() {
		__validFields.clear();
		fileSystem.clear();
		queryResultsDir.clear();
		slaveName.clear();
	}

	// equals implementation 
	public final boolean equals(final Object peer_) {
		if (!(peer_ instanceof BaseConfig)) {
			return false;
		}
		if (peer_ == this) {
			return true;
		}
		BaseConfig peer = (BaseConfig) peer_;
		boolean ret = __validFields.equals(peer.__validFields);
		if (!ret)
			return ret;
		if (__validFields.get(Field_FILESYSTEM)) {
			ret = fileSystem.equals(peer.fileSystem);
			if (!ret)
				return ret;
		}
		if (__validFields.get(Field_QUERYRESULTSDIR)) {
			ret = queryResultsDir.equals(peer.queryResultsDir);
			if (!ret)
				return ret;
		}
		if (__validFields.get(Field_SLAVENAME)) {
			ret = slaveName.equals(peer.slaveName);
			if (!ret)
				return ret;
		}
		return ret;
	}

	// clone implementation 
	@SuppressWarnings("unchecked")
	public final Object clone() throws CloneNotSupportedException {
		BaseConfig other = new BaseConfig();
		other.__validFields.or(this.__validFields);
		if (__validFields.get(Field_FILESYSTEM)) {
			other.fileSystem = (TextBytes) this.fileSystem.clone();
		}
		if (__validFields.get(Field_QUERYRESULTSDIR)) {
			other.queryResultsDir = (TextBytes) this.queryResultsDir.clone();
		}
		if (__validFields.get(Field_SLAVENAME)) {
			other.slaveName = (TextBytes) this.slaveName.clone();
		}
		return other;
	}

	// merge implementation 
	@SuppressWarnings("unchecked")
	public final void merge(BaseConfig peer) throws CloneNotSupportedException {
		__validFields.or(peer.__validFields);
		if (peer.__validFields.get(Field_FILESYSTEM)) {
			this.fileSystem = (TextBytes) peer.fileSystem.clone();
		}
		if (peer.__validFields.get(Field_QUERYRESULTSDIR)) {
			this.queryResultsDir = (TextBytes) peer.queryResultsDir.clone();
		}
		if (peer.__validFields.get(Field_SLAVENAME)) {
			this.slaveName = (TextBytes) peer.slaveName.clone();
		}
	}

	// hashCode implementation 
	public final int hashCode() {
		int result = 1;
		result = MurmurHash.hash(fileSystem.getBytes(), fileSystem.getOffset(), fileSystem.getLength(), result);
		result = MurmurHash.hash(queryResultsDir.getBytes(), queryResultsDir.getOffset(), queryResultsDir.getLength(),
				result);
		result = MurmurHash.hash(slaveName.getBytes(), slaveName.getOffset(), slaveName.getLength(), result);
		return result;
	}
}
